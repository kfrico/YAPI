'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const uid = require('uid-safe');
const deepEqual = require('deep-equal');
const Store = require('./store');
const MemoryStore = require('./memory_store');

const ONE_DAY = 24 * 3600 * 1000;

const cookieOpt = cookie => {
  const options = Object.assign({
    maxAge: 0,
    path: '/',
    httpOnly: true
  }, cookie || {}, {
    overwrite: true,
    signed: false });
  if (!(options.maxAge >= 0)) options.maxAge = 0;
  return options;
};

const deleteSession = (ctx, key, cookie, store, sid) => {
  const options = cookie instanceof Function ? cookieOpt(cookie(ctx)) : Object.assign({}, cookie);
  delete options.maxAge;
  ctx.cookies.set(key, null, options);
  store.destroy(`${ key }:${ sid }`);
};

const saveSession = (ctx, key, cookie, store, sid) => {
  const options = cookie instanceof Function ? cookieOpt(cookie(ctx)) : cookie;
  const ttl = options.maxAge > 0 ? options.maxAge : ONE_DAY;
  ctx.cookies.set(key, sid, options);
  store.set(`${ key }:${ sid }`, ctx.session, ttl);
};

module.exports = options => {
  const opt = options || {};
  const key = opt.key || 'koa:sess';
  const store = new Store(opt.store || new MemoryStore());
  const cookie = opt.cookie instanceof Function ? opt.cookie : cookieOpt(opt.cookie);

  return (() => {
    var _ref = _asyncToGenerator(function* (ctx, next) {
      const cookieSid = ctx.cookies.get(key);

      let sid = cookieSid;
      if (!sid) {
        sid = uid.sync(24);
        ctx.session = {};
      } else {
        ctx.session = yield store.get(`${ key }:${ sid }`);
        if (!ctx.session || typeof ctx.session !== 'object') {
          ctx.session = {};
        }
      }

      const sessionClone = JSON.parse(JSON.stringify(ctx.session));

      ctx.sessionHandler = {
        regenerateId: function () {
          sid = uid.sync(24);
        }
      };

      yield next();

      const sessionHasData = ctx.session && Object.keys(ctx.session).length > 0;

      if (sid !== cookieSid) {
        if (cookieSid) deleteSession(ctx, key, cookie, store, cookieSid);

        if (sessionHasData) saveSession(ctx, key, cookie, store, sid);
      } else {
        if (deepEqual(ctx.session, sessionClone)) return;

        const doSession = sessionHasData ? saveSession : deleteSession;
        doSession(ctx, key, cookie, store, sid);
      }
    });

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })();
};